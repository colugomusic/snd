#pragma once

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <functional>
#include <vector>

namespace snd {

// 
// All memory is allocated in the constructor
//
// You can call write() in the audio thread if you're feeling adventurous
//
// There is no locking. It is the caller's responsibility not to
// simultaneously read and write to the same region
//
class SampleMipmap
{
public:

	// Values are encoded as uint_8s:
	//   0 == -1
	// 127 ==  0
	// 254 == +1
	using Frame = uint8_t;
	static constexpr Frame SILENT{ 127 };

	struct LODFrame
	{
		Frame min;
		Frame max;
	};

	struct Region
	{
		uint64_t beg{};
		uint64_t end{};
	};

	// that 'detail' parameter:
	//	lower is better quality, but uses more memory
	//	detail=0 is a regular mipmap, i.e. each level is half the size of the previous one
	//	detail=1 each level is 1/3 the size of the previous one
	//  detail=2 1/4, detail=3 1/5, etc. 
	//
	// level zero is always the original sample size
	SampleMipmap(uint16_t channel_count, uint64_t frame_count, uint8_t detail = 0);

	// Copying is disabled. Move support is generated by the compiler
	SampleMipmap(const SampleMipmap& rhs) = delete;
	SampleMipmap& operator=(const SampleMipmap& rhs) = delete;
	SampleMipmap(SampleMipmap&& rhs) = default;
	SampleMipmap& operator=(SampleMipmap&& rhs) = default;

	auto lod_count() const { return lods_.size() + 1; }
	auto bin_size_to_lod(float bin_size) const -> float;

	// Interpolate between two LODs and two frames
	auto read(float lod, uint16_t channel, float frame) const -> LODFrame;

	// Interpolate between two frames of the same LOD
	auto read(uint16_t lod_index, uint16_t channel, float frame) const -> LODFrame;

	// No interpolation.
	// lod_frame is the LOD-local frame, i.e. in a 100-frame sample
	// with detail=0 so each LOD is half the size of the previous,
	// the lod_frame parameter would range from
	// 0-99 for LOD 0,
	// 0-49 for LOD 1,
	// 0-24 for LOD 2, etc.
	auto read(uint16_t lod_index, uint16_t channel, uint64_t lod_frame) const -> LODFrame;

	// Writes level zero data. Mipmap data for the other levels won't be generated until update() is called
	auto write(uint16_t channel, uint64_t frame, float value) -> void;

	// Write level zero frame data beginning at frame_begin, using a custom writer function
	// The writer needs to encode the frames to the range 0..254 itself
	auto write(uint16_t channel, uint64_t frame_begin, std::function<void(Frame* data)> writer) -> void;

	// Generates mipmap data for the specified (top-level) region
	// This does both reading and writing of frames within the
	// region at all mipmap levels
	auto update(Region region) -> void;

	static auto encode(float value) -> SampleMipmap::Frame;

private:

	struct LOD
	{
		using Channel = std::vector<LODFrame>;
		using Data = std::vector<Channel>;

		const int index;
		const int bin_size;

		Data data;

		LOD(int index, uint16_t channel_count, uint64_t frame_count, uint8_t detail);
	};

	struct LOD0
	{
		using Channel = std::vector<Frame>;
		using Data = std::vector<Channel>;

		Data data;
	};

	auto read(uint16_t channel, float frame) const -> Frame;
	auto read(uint16_t channel, uint64_t frame) const -> Frame;
	auto read(const LOD& lod, uint16_t channel, uint64_t lod_frame) const -> LODFrame;
	auto generate(LOD* lod, Region region) -> void;
	auto generate(LOD* lod, uint16_t channel, Region region) -> void;
	auto generate(LOD* lod, uint16_t channel, uint64_t frame) -> void;

	uint16_t channel_count_;
	uint64_t frame_count_;
	uint8_t detail_;
	LOD0 lod0_;
	std::vector<LOD> lods_;
};

namespace detail {

template <class T>
struct LerpHelper
{
	const struct
	{
		const T a;
		const T b;
	} index;

	const float t;

	LerpHelper(float frame)
		: index{ static_cast<T>(std::floor(frame)), static_cast<T>(std::ceil(frame)) }
		, t{ frame - index.a }
	{
	}

	template <class Result, class Value>
	auto lerp(Value a, Value b) const -> Result
	{
		const auto af{ static_cast<float>(a) };
		const auto bf{ static_cast<float>(b) };

		return static_cast<Result>((t * (bf - af)) + af);
	}
};

} // detail

inline SampleMipmap::LOD::LOD(int index, uint16_t channel_count, uint64_t frame_count, uint8_t detail)
	: index{ index }
	, bin_size{ int(std::pow(detail, index)) }
	, data{ static_cast<size_t>(channel_count), Channel(frame_count, LODFrame{ SILENT, SILENT }) }
{
	assert(detail >= 2);
}

inline SampleMipmap::SampleMipmap(uint16_t channel_count, uint64_t frame_count, uint8_t detail)
	: channel_count_{ channel_count }
	, frame_count_{ frame_count }
	, detail_{ static_cast<uint8_t>(detail + 2) }
	, lod0_{ LOD0::Data{ static_cast<size_t>(channel_count), LOD0::Channel(static_cast<size_t>(frame_count), SILENT)} }
{
	auto size{ frame_count / detail_ };

	int index{ 1 };

	while (size > 0)
	{
		lods_.push_back(LOD{ index, channel_count, size, detail_ });

		index++;
		size /= detail_;
	}
}

inline auto SampleMipmap::read(float lod, uint16_t channel, float frame) const -> LODFrame
{
	assert(channel < channel_count_);
	assert(lod >= 0);
	assert(lod <= lods_.size());

	const detail::LerpHelper<uint16_t> lerp_lod{ lod };

	const auto a_value{ read(lerp_lod.index.a, channel, frame) };
	const auto b_value{ read(lerp_lod.index.b, channel, frame) };

	const auto min{ lerp_lod.lerp<Frame>(a_value.min, b_value.min) };
	const auto max{ lerp_lod.lerp<Frame>(a_value.max, b_value.max) };

	return { min, max };
}

inline auto SampleMipmap::read(uint16_t lod_idx, uint16_t channel, float frame) const -> LODFrame
{
	assert(channel < channel_count_);

	if (lod_idx == 0)
	{
		const auto value{ read(channel, frame) };

		return { value, value };
	}

	assert(lod_idx <= lods_.size());

	const auto& lod{ lods_[lod_idx - 1] };

	frame /= lod.bin_size;

	const detail::LerpHelper<uint64_t> lerp_frame{ frame };

	const auto a_value{ read(lod, channel, lerp_frame.index.a) };
	const auto b_value{ read(lod, channel, lerp_frame.index.b) };

	const auto min{ lerp_frame.lerp<Frame>(a_value.min, b_value.min) };
	const auto max{ lerp_frame.lerp<Frame>(a_value.max, b_value.max) };

	return { min, max };
}

inline auto SampleMipmap::read(uint16_t lod_idx, uint16_t channel, uint64_t lod_frame) const -> LODFrame
{
	assert(channel < channel_count_);

	if (lod_idx == 0)
	{
		const auto value{ read(channel, lod_frame) };

		return { value, value };
	}

	assert(lod_idx <= lods_.size());

	const auto& lod{ lods_[lod_idx - 1] };

	return read(lod, channel, lod_frame);
}

inline auto SampleMipmap::read(const LOD& lod, uint16_t channel, uint64_t lod_frame) const -> LODFrame
{
	lod_frame = std::min(uint64_t(lod.data[0].size() - 1), lod_frame);

	return lod.data[channel][lod_frame];
}

inline auto SampleMipmap::read(uint16_t channel, float frame) const -> Frame
{
	const detail::LerpHelper<uint64_t> lerp_frame{ frame };

	const auto a_value{ read(channel, lerp_frame.index.a) };
	const auto b_value{ read(channel, lerp_frame.index.b) };

	return lerp_frame.lerp<Frame>(a_value, b_value);
}

inline auto SampleMipmap::read(uint16_t channel, uint64_t frame) const -> Frame
{
	frame = std::min(uint64_t(lod0_.data[0].size() - 1), frame);

	return lod0_.data[channel][frame];
}

inline auto SampleMipmap::encode(float value) -> SampleMipmap::Frame
{
	value = std::clamp(value, -1.0f, 1.0f);
	value += 1;
	value *= 127;

	return static_cast<SampleMipmap::Frame>(value);
}

inline auto SampleMipmap::write(uint16_t channel, uint64_t frame, float value) -> void
{
	lod0_.data[channel][frame] = encode(value);
}

inline auto SampleMipmap::write(uint16_t channel, uint64_t frame_begin, std::function<void(uint8_t* data)> writer) -> void
{
	writer(&lod0_.data[channel][frame_begin]);
}

inline auto SampleMipmap::generate(LOD* lod, uint16_t channel, uint64_t frame) -> void
{
	Frame min{ 255 };
	Frame max{ 0 };

	uint64_t beg{ frame * detail_ };
	uint64_t end{ beg + detail_ };

	for (uint64_t i{ beg }; i < end; i++)
	{
		const auto frame{ read(lod->index - 1, channel, i) };

		if (frame.min < min) min = frame.min;
		if (frame.max > max) max = frame.max;
	}

	lod->data[channel][frame] = { min, max };
}

inline auto SampleMipmap::generate(LOD* lod, uint16_t channel, Region region) -> void
{
	for (uint64_t frame{ region.beg }; frame < region.end; frame++)
	{
		generate(lod, channel, frame);
	}
}

inline auto SampleMipmap::generate(LOD* lod, Region region) -> void
{
	for (uint16_t channel{}; channel < channel_count_; channel++)
	{
		generate(lod, channel, region);
	}
}

inline auto SampleMipmap::update(Region region) -> void
{
	assert(region.end > region.beg);
	assert(region.end <= lod0_.data[0].size());

	for (auto& lod : lods_)
	{
		region.beg /= detail_;
		region.end /= detail_;

		generate(&lod, region);
	}
}

inline auto SampleMipmap::bin_size_to_lod(float bin_size) const -> float
{
	if (bin_size <= 1) return 0.0;

	return float(std::log(bin_size) / std::log(detail_));
}

} // snd
